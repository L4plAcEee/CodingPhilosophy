---
笔记: 2025-06-28
摘要: 
tags:
  - 题解
---
## [P1032 [NOIP 2002 提高组] 字串变换](https://www.luogu.com.cn/problem/P1032)
### 思路
解空间为树结构 （最大深度为10），考虑bfs 或 dfs进行搜索
因为需要查找最小次数，所以这里采用bfs。

### 勘误
#### 1. 忘记新建 newstr 进行操作了
#### 2. ⚠️ 情况举例：多处可替换时的最短路径可能被错过！
> 最开始的实现是简单的find匹配，这样只会匹配第一个遇到的子串，这会导致在多处可替换的情况下错过最短路径。

如果当前字符串为 `"program"`，我们来枚举所有可能的**一步替换结果**：

- 使用 `"g → ce"`：`progra**g**` → `progra**ce**` → `prograce`
    
- 使用 `"ra → dur"`：`prog**ra**m` → `prog**dur**m` → `progdurm`
    
- 使用 `"am → ee"`：`progr**am**` → `progr**ee**` → `progree`
    
- 使用 `"ee → am"`：`（不适用）`
    

所以你当前写法下，这一轮队列只扩展 3 个新状态：

- prograce
    
- progdurm
    
- progree
    

### 解
```cpp
string A, B;
vector<pair<string, string>> rules;

void bfs() {
    int depth = 0;
    queue<string> q;
    unordered_set<string> visited;
    q.push(A);
    visited.insert(A);
    while (!q.empty()) {
        int size = q.size();
        while (size--) {
            string s = q.front();q.pop();
            for (auto &rule : rules) {
                auto [pattern, replacement] = rule;

                for (size_t pos = s.find(pattern); pos != string::npos; pos = s.find(pattern, pos + 1)) {
                    string new_str = s;
                    new_str.replace(pos, pattern.length(), replacement);

                    if (new_str == B) {
                        cout << depth + 1 << '\n';
                        return;
                    }

                    if (visited.find(new_str) == visited.end()) {
                        visited.insert(new_str);
                        q.push(new_str);
                    }
                }        
            }
        }
        depth++;
        if (depth > 10) break;
    }
    cout << "NO ANSWER!" << '\n';
}

int main() {
    cin >> A >> B;
    string line;
    while (getline(cin, line)) {
        istringstream ls(line);
        string a, b;
        if (ls >> a >> b) {
            rules.emplace_back(a, b);
        }
    }
    bfs();
}
```