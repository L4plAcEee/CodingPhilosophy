## Daily::算法 @[P3799 小 Y 拼木棒](https://www.luogu.com.cn/problem/P3799)
### 思路
> 对于 100% 的数据，保证 $1≤n≤10^5，1≤a_i​≤5×10^3$。

~~答案应该要是 $O(nlog(n))$ 左右的，题目要求遍历，但是答案与顺序无关。~~
题目的意思是：
	找到一个 $四元组(L1, L2, L3, L4) 满足 L1 + L2 = L3 = L4$ 

### 抄
欲由4根木棒组成一个正三角形，则必有 **2根长度相等**。  
且另外2根长度之和，等于 **前2根相等的木棒 的长度**。

发现 各木棍 的长度 ai​≤5000，时间复杂度 O(n2) 可过。  
考虑直接用两层循环，**暴力枚举** 上述两种木棒的长度，计算方案数并累加。

![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/9e3939761c85f32b471603a3d1e2396e_MD5.jpeg)

#### 复现代码
```cpp
const int MOD = 1e9 + 7;
const int MAXN = 1e5 + 5;
const int MAXA = 1e4 + 5;
int n, a[MAXN], cnt[MAXA] = {0};

int C (int x, int k) {
    return (k == 1 ? x : x * (x - 1) / 2) % MOD;
}

int32_t main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n;
    int max_a = 0, ans = 0;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        max_a = max(a[i], max_a);
        cnt[a[i]]++;
    }
    //枚举两根相等的边
    for (int i = 2; i <= max_a; ++i) {
        if (cnt[i] >= 2) {
	        //求出组合数
            int times = C(cnt[i], 2) % MOD;
            //枚举被合成的边(到i / 2即可)
            for (int j = 1; j <= i / 2; ++j) {
	            //用来合成的木棒长度不等 
                if (j != i - j && cnt[j] >= 1 && cnt[i - j] >= 1) 
                    ans += times * C(cnt[j], 1) * C(cnt[i - j], 1) % MOD;
                //用来合成的木棒长度相等 
                if (j == i - j && cnt[j] >= 2) 
                    ans += times * C(cnt[j], 2) % MOD;
                ans %= MOD;
            }
        }
    }
    cout << ans << '\n';
    
}
```

---
