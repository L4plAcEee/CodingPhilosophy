## Daily::算法 @[P2437 蜜蜂路线](https://www.luogu.com.cn/problem/P2437)
### 题目描述
一只蜜蜂在下图所示的数字蜂房上爬动,已知它只能从标号小的蜂房爬到标号大的相邻蜂房,现在问你：蜜蜂从蜂房 m 开始爬到蜂房 n，m<n，有多少种爬行路线？（备注：题面有误，右上角应为 n−1）

![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/67fff3cca63c3ab33463ed7b9834095b_MD5.webp)

### 思路#0 
> <memorize_dfs> <-40pt.

类似 斐波那契数列 ，直接记忆化搜索尝试。
过不了是因为数字太大了，需要高精度加法。
#### 关键代码
```cpp
#define int long long
int m, n;
int memo[1005];

int memorize_dfs(int i) {
    if (i < m) return 0;
    if (i == m) return 1;
    if (memo[i] != -1) return memo[i];

    return memo[i] = memorize_dfs(i - 1) + memorize_dfs(i - 2);
}
```

### 思路#1 
> <memorize_dfs + 高精度加法> <-AC
#### 关键代码
```cpp
string str_add(string const &a, string const &b) {
    string ret = string(max(a.length(), b.length()) + 1, '0');
    int i = a.length() - 1, j = b.length() - 1, k = ret.length() - 1, carry = 0;
    while (i >= 0 || j >= 0 || carry) {
        int x = (i >= 0 ? a[i--] - '0' : 0);
        int y = (j >= 0 ? b[j--] - '0' : 0);
        int sum = x + y + carry;
        carry = sum / 10;
        ret[k--] = '0' + (sum % 10);
    }
    while (ret.size() > 1 && ret[0] == '0') ret.erase(0, 1);
    return ret;
} 
```

#### Mistake
1. **未处理 i 或 j 尚未遍历完的情况**  
    如果 `a` 和 `b` 长度不等，只处理了 `i >= 0 && j >= 0` 的交集，未处理剩余的部分。
2. **进位处理不完整（k=0 的时候）**  
    当最高位有进位（如 999 + 1 = 1000），`ret[0]` 会是有效的 `'1'`，否则就是 `'0'`。但你在：
    `ret[k] = '0' + carry;`
    只写了一位，而没有处理后续进位（如果 carry == 1 且 k == 0，可能仍有问题）。
3. **删除前导零可能导致空字符串**  
    如果结果是 `"0"`（比如 `a = "0", b = "0"`），你会删成空字符串，造成不合法的返回值。

### 思路#2 
> <空间压缩DP + 高精加> <-AC
#### 关键代码
```cpp
string dp(int i) {
    string pre1 = "1", pre2 = "0", cur = "-1";
    if (i == n) return pre2;
    if (i + 1 == n) return pre1;
    for (int idx = i + 1; idx <= n; ++idx) {
        cur = str_add(pre1, pre2);
        pre2 = pre1;
        pre1 = cur;
    }
    return cur;
}
```
---
