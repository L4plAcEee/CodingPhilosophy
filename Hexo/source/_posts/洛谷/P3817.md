## Daily::算法 @[P3817 小A的糖果](https://www.luogu.com.cn/problem/P3817)
### 思路
~~贪心思路：
每次挑最多的吃，依此法检定，直到不吃也能满足条件。~~

### 勘误
#### 主要问题
1. **left 和 right 设置错误**：代码只为中间的糖果盒设置了 left 和 right 值，但第一个和最后一个盒子也需要考虑相邻关系。
2. **排序策略错误**：这是一个贪心问题，但不需要排序。应该从左到右依次处理，确保每对相邻盒子的约束都满足。
3. **逻辑错误**：排序后破坏了原有的相邻关系，导致解法完全错误。

#### 正确的解法
这是一个经典的贪心问题，正确的策略是：

- 从左到右遍历每对相邻的盒子
- 如果当前相邻对的糖果总数超过 x，就从右边的盒子中吃掉多余的糖果
- 这样可以保证局部最优，并且不会影响已经处理过的约束

### 解
#### 算法正确性分析
#### 核心算法：贪心策略
算法分为两个关键步骤：
**第一步：预处理单个盒子**
```cpp
// 确保每个盒子的糖果数都不超过x
for (int i = 1; i <= n; ++i) {
    if (a[i] > x) {
        sum += a[i] - x;  // 吃掉多余的糖果
        a[i] = x;         // 最多保留x颗
    }
}
```
**第二步：处理相邻约束**
```cpp
// 从左到右处理相邻盒子的约束
for (int i = 2; i <= n; ++i) {
    if (a[i] + a[i-1] > x) {
        long long eat = a[i] + a[i-1] - x;
        sum += eat;
        a[i] = x - a[i-1];  // 贪心：让a[i] + a[i-1] = x
    }
}
```

1. **第一步的必要性**：如果任何盒子的糖果数超过x，那么它与任何相邻盒子的和都会超过x，违反约束条件。
2. **第二步的贪心策略**：
    - 从左到右处理，确保已处理的约束不会被破坏
    - 对于违反约束的相邻对，总是从右边的盒子减糖
    - 让相邻和刚好等于x（即$a[i] = x - a[i-1]$），为后续处理留出最大空间
3. **全局最优性**：每步都是局部最优，且不会产生额外的约束冲突，因此达到全局最优。

#### 关键要点

- **数据类型**：使用`long long`避免整数溢出
- **索引方式**：使用1-indexed更符合题目描述和竞赛习惯
- **边界处理**：预处理步骤确保不会出现糖果数为负的情况
- **时间复杂度**：O(n)，空间复杂度：O(n)

#### 易错点

1. **忘记预处理**：直接处理相邻约束而忽略单个盒子可能超过x的情况
2. **贪心策略错误**：错误地尝试排序或使用其他非贪心方法
3. **数据类型问题**：使用int导致大数据下溢出
4. **索引混乱**：0-indexed和1-indexed混用导致边界错误

#### 代码
```cpp
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, x;
    cin >> n >> x;
    
    vector<long long> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }
    
    long long sum = 0;
    
    // 第一步：确保每个盒子的糖果数都不超过x
    for (int i = 1; i <= n; ++i) {
        if (a[i] > x) {
            sum += a[i] - x;  // 吃掉多余的糖果
            a[i] = x;         // 最多保留x颗
        }
    }
    
    // 第二步：处理相邻约束
    for (int i = 2; i <= n; ++i) {
        if (a[i] + a[i-1] > x) {
            long long eat = a[i] + a[i-1] - x;
            sum += eat;
            a[i] = x - a[i-1];  // 贪心：让a[i] + a[i-1] = x
        }
    }
    
    cout << sum << endl;
    return 0;
}
```

