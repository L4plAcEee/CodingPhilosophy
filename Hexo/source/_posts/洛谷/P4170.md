---
笔记: 2025-07-02
摘要: https://www.luogu.com.cn/problem/P4170
tags:
  - 题解
---
## 解析
假设你有一条长度为 5 的木板，初始时没有涂过任何颜色。你希望把它的 5 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 5 的字符串表示这个目标：RGBGR。

每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 RRRRR，第二次涂成 RGGGR，第三次涂成 RGBGR，达到目标。

用尽量少的涂色次数达到目标。

## 想法
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/8027406a6ae10c1f8b29e239fc3f7208_MD5.jpeg)

 >  似乎有灵感了，看毛题解，不看，自己写
 >  写毛，我是傻逼

![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/222a4ffef128bdec6464325a35bfc069_MD5.jpeg)
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/4019c4b369d12713824a07e42df7fd78_MD5.jpeg)

## 解
```cpp
#include <bits/stdc++.h>
using namespace std;

string t;
// vector<vector<int>> dp(51, vector<int>(51, -1));
vector<vector<int>> dp(51, vector<int>(51, 0));

int f(int l, int r) {
    if (l > r) return 0;
    if (l == r) return 1;
    if (dp[l][r] != -1) return dp[l][r];
    dp[l][r] = t[l] == t[r] ? f(l , r - 1) : INT_MAX;
    for (int m = l; m < r; ++m) {
        dp[l][r] = min(dp[l][r], f(l, m) + f(m + 1, r));
    }
    return dp[l][r];
 }

void solve() {
    int len = t.length();
    for (int i = 0; i < len; ++i) 
        dp[i][i] = 1;
    
    for (int i = len - 1; i >= 0; --i) {
        for (int j = i + 1; j < len; ++j) {
            dp[i][j] = t[i] == t[j] ? dp[i][j - 1] : INT_MAX;
            for (int k = i; k < j; ++k) 
                dp[i][j] = min(dp[i][j], f(i, k) + f(k + 1, j));
        }
    }
    cout << dp[0][len - 1];
}


int main() {
    cin >> t;
    // cout << f(0, t.length() - 1) << '\n';
    solve();
}
```

 
 