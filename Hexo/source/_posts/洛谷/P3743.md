## Daily::算法 @[P3743 小鸟的设备](https://www.luogu.com.cn/problem/P3743)
### 思路
> 对于 100% 的数据，$1≤n≤100000，1≤p≤100000，1≤ai​,bi​≤100000$。

首先看答案单调性
题目要求：求最大使用时限 
-> 注意到，比这个小的时限也合法，但是比这个时限大的时间就非法，单调性成立。
-> 二分答案思路成立
设计 Check逻辑：
每个设备的初始持续时间为 $b_i / a_i$ ，
如果给某个设备充电，则可以为其增加 $t_i*p/a_i$ 的持续时间。 
然后遍历所有设备，检查满足初始持续时间小于 ans 的设备，然后为其分润 时间 去充电直到持续时间 == ans，并记录所需时间，假如记录的时间和  > ans ，则ans 非法。

### 勘误
看了你的原代码，我来评价一下：

#### 主要问题

1. **精度处理过度复杂**
    
    ```cpp
    const int preci = 1e5;
    p *= preci;
    a[i] *= preci;
    b[i] *= preci;
    ```
    
    你把所有数值都放大了10⁵倍来处理精度，这个思路不错，但实际上这题用浮点二分更简单直接。
    
2. **check函数逻辑错误**
    
    ```cpp
    if (b[i] / a[i] < ans) {
        t += (ans - b[i] / a[i]) / (p / a[i]);
    }
    ```
    
    这里的逻辑有问题：
    
    - `b[i] / a[i]` 表示设备i能独立运行的时间
    - 但你需要计算的是在时间`ans`内，设备i需要多少充电时间
    - 正确的应该是：如果 `ans * a[i] > b[i]`，需要充电 `(ans * a[i] - b[i]) / p` 的时间
3. **二分搜索的边界处理**
    
    ```cpp
    if (check(mid)) {
        r = mid - 1;  // 这里有问题
    }
    ```
    
    你在找最大值，但当`check(mid)`返回true时，应该是`l = mid + 1`，而不是`r = mid - 1`。
    
4. **输出错误**
    
    ```cpp
    cout << r / (double)preci << '\n';
    ```
    
    二分结束后，`r`不一定是正确答案，应该输出`l`或者用额外变量记录答案。
    

#### 优点

1. **二分思路正确**：用二分搜索找答案是对的
2. **整体框架合理**：输入处理、二分框架都没问题
3. **考虑了精度问题**：虽然方法复杂，但确实在考虑精度

#### 修正建议

你的核心思路是对的，主要是实现细节有问题。如果要保持你的整数二分思路，主要需要修正check函数的逻辑和二分的边界处理。不过对于这种有精度要求的题目，直接用浮点二分会更简洁。

你的代码展现了良好的算法思维，就是在一些实现细节上需要更仔细一些。


### 解
#### 为什么浮点二分要这样写？
**整数二分**：
- 可以用 `l <= r` 或 `l < r` 判断
- 因为整数有最小单位1，总能收敛到确定值

**浮点二分**：
- 不能用 `l <= r` 或 `l < r`，因为浮点数理论上可以无限细分
- 必须用**固定迭代次数**或**精度判断** `r - l < eps`

#### 代码
```cpp
int n, p;
vector<int> a, b;

bool check(double ans) {
    double t = 0;
    for (int i = 0; i < n; ++i) {
        double needed = ans * a[i];  // 在时间ans内设备i需要的总能量
        if (needed > b[i]) {         // 如果需要的能量超过初始存储
            double deficit = needed - b[i];  // 缺少的能量
            t += deficit / p;                // 需要充电的时间
        }
        if (t > ans) return false;   // 如果总充电时间超过ans，不可行
    }
    return true;
}

int main() {
    cin >> n >> p;
    
    a.resize(n);
    b.resize(n);
    
    if (check(1e15)) {
        cout << -1 << endl;
        return 0;
    }
    double l = 0, r = 1e15;  // 改为double类型
    
    // 浮点二分，迭代足够次数保证精度
    for (int iter = 0; iter < 100; ++iter) {
        double mid = (l + r) / 2.0;
        if (check(mid)) {
            l = mid;  // 如果可行，答案可能更大
        } else {
            r = mid;  // 如果不可行，答案应该更小
        }
    }
    
    cout << fixed << setprecision(10) << l << endl;
    return 0;
}
```

---
