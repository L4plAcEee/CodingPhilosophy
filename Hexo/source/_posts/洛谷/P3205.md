---
笔记: 2025-07-02
摘要: https://www.luogu.com.cn/problem/P3205
tags:
  - 题解
---
## 分析
题目的要求就是，有多少种 初始队形 通过题目给定的规则进行变换，可以得到 理想队形。

## 想法
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/352710fccc37b77804a5c7f68ac4ba18_MD5.jpeg)

> 明显弱智想法XD（上面的）
> 似乎想到了，但是很模糊，但是我知道应该是这么说：
> 问题的状态应该定义为，对于$[l, r]$，得到以 $A_l$ 开头 以 $A_r$ 结尾的队列有几种方法

## 怎么想到区间DP
### case1
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/7f9a28b0fd20a93a401815b5a99b6805_MD5.jpeg)

### case2
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/35e42bde46fffbd2070e655cfa42bb68_MD5.jpeg)

## 正确的思路
问题可以抽象为：$dp[l][r][s]$ 表示：当区间来到了，左端点为 l 右端点为 r，s 属于 $[0, 1]$ ，表示以左端点或者右端点作为结尾时的问题状态， 也就是说， 该dp表示，当左端点来到了 l，右端点来到了 r 时，A(l, r)作为序列时以左或者右端点作为结尾时有多少种方案。
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/f5fae3e365a32254d7abf3e3c5853360_MD5.jpeg)


## 错误关键原因：长度为 2 的区间被重复计数

在严格递推公式中，你的 C++ 迭代写法对每个 `i<j` 都执行了下面四条转移：

```cpp
if (arr[i] < arr[i+1]) dp[i][j][0] += dp[i+1][j][0];
if (arr[i] < arr[j])   dp[i][j][0] += dp[i+1][j][1];
if (arr[j] > arr[j-1]) dp[i][j][1] += dp[i][j-1][1];
if (arr[j] > arr[i])   dp[i][j][1] += dp[i][j-1][0];
```

但当 `j == i+1`（即区间长度恰好为 2）时，会出现以下重复计数：

- 对于 `dp[i][i+1][0]`，`arr[i]<arr[i+1]` 和 `arr[i]<arr[j]` 其实是同一句判断，都会把各自的子状态都加进来，导致加了两次。
    
- 对于 `dp[i][i+1][1]` 同理，也被加了两次。
    

而正确的逻辑（和 Java 版一样）是 **只对长度 ≥ 3 的区间同时使用这四条转移**，长度为 2 时应当由显式初始化：

```cpp
// 对长度为2的区间，仅当 nums[i] < nums[i+1] 时
// dp[i][i+1][0] = 1, dp[i][i+1][1] = 1
```

这样对于样例 `[1701,1702,1703,1704]`：

- Java 版对长度2 仅初始化一次，dp[0][1]={1,1}，dp[1][2]={1,1}，dp[2][3]={1,1}。
    
- 而 C++ 版却把它们都算成 `{2,2}`，导致整棵 DP 树向上滚动时翻倍，最后给出了 16。
    

---

## 修复方法

### 方法一：特殊初始化长度为 2

在迭代主体前，先对所有 `i` 做：

```cpp
if (arr[i] < arr[i+1]) {
    dp[i][i+1][0] = 1;
    dp[i][i+1][1] = 1;
}
```

然后在双重循环中**让 `j` 从 `i+2` 开始**，即只处理长度 ≥ 3 的区间：

```cpp
for (int i = n - 1; i >= 0; --i) {
    for (int j = i + 2; j < n; ++j) {
        // 只在长度 >= 3 时才用这四条转移
        …
    }
}
```

### 方法二：在转移里加判定

在第二、第四条合并转移前，加上 `if (j > i + 1)` 的判断，确保它们不会跑到长度 2 的区间上。

---

采用以上任一修复后，你的 C++ 版就会和 Java 参考解保持一致，样例输出也会变成 8 而不是 16。

## 解
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 19650827;

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; ++i) cin >> arr[i];
    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(2, 0)));
    for (int i = 0; i < n; ++i) if (arr[i] < arr[i+1]) dp[i][i+1][0] = dp[i][i+1][1] = 1;



    for (int i = n - 1; i >= 0; --i) {
        for (int j = i + 2; j < n; ++j) {
            if (arr[i] < arr[i + 1]) dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][0]) % MOD; 
            if (arr[i] < arr[j]) dp[i][j][0] = (dp[i][j][0] + dp[i + 1][j][1]) % MOD;
            if (arr[j] > arr[j - 1]) dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][1]) % MOD;
            if (arr[j] > arr[i]) dp[i][j][1] = (dp[i][j][1] + dp[i][j - 1][0]) % MOD;
        }
    }

    cout << (dp[0][n - 1][0] + dp[0][n - 1][1]) % MOD<< '\n';
}
```