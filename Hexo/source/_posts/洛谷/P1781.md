## Daily::每日一题 @[P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)
### 题目描述
地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 n 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。

> 票数可能会很大，可能会到 100 位数字，且 $1≤n≤20$ 。

### 思路
基本思路：高精度 + 排序
高精度 -> 大数string
排序 -> 基排？手写比较器？

所以思路很清晰了 手写string比较器

### 1. 60pt
只过了 60% 的点
原来是没注意到 自己的 逻辑错误了，从末尾往前比了。

### 2. AC
#### 关键代码
```cpp
bool cmp(pair<string, int> &pa, pair<string, int> &pb) {
    string &a = pa.first, &b = pb.first;
    // 1. 按长度降序
    if (a.size() != b.size()) {
        return a.size() > b.size();
    }
    // 2. 等长时，直接用 lexicographical compare
    if (a != b) {
        return a > b;  // 字符串 operator> 默认是从前往后比较
    }
    // 3. 完全相同时，保证编号小的优先
    return pa.second < pb.second;
}
```

#### 关键点
1. 大数string 高位在开头，别老是粗心搞错
2. cpp中不需要循环比较，本身对于string就重载了比较符号，基于字典序比较（lexicographical compare）

### 优化
#### 优化一：lambda
```cpp
    sort(v.begin(), v.end(), [](pair<string, int> &a, pair<string, int> &b) {
        if (a.first.length() != b.first.length())
            return a.first.length() > b.first.length();
        if (a.first != b.first) return a.first > b.first;
        return a.second < b.second;
    });
```

#### 优化二：pair支持重载符号
`std::pair` 在标准库里已经给你实现好了所有的比较运算符（`==, !=, <, <=, >, >=`），它们的行为都是**先比较 `.first`，如果 `.first` 相等再比较 `.second`**
所以：
```cpp
if (a.first != b.first) return a.first > b.first;
return a.second < b.second;
```
等价于
```cpp
return a < b;
```

---
