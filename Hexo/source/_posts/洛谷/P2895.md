---
笔记: 2025-06-17
属性:
  - <搜索Search>
tags:
  - 题解
---
## [P2895 [USACO08FEB] Meteor Shower S](https://www.luogu.com.cn/problem/P2895)
### 思路
实际上还是 最短到达问题 -> BFS
如果 该格子的最短到达时间 < 被烧焦时间，即安全格子。

### 勘误
你给出的代码存在以下几个关键问题：

1. **边界条件判断错误：**
    
    `if (nx < 0 || nx > MAXN || ny < 0 || ny > MAXN)`
    
    应该是：
    
    `if (nx < 0 || nx >= MAXN || ny < 0 || ny >= MAXN)`
    
    否则会导致访问数组越界。
    
2. **移动方向不完整：**  
    你在 `bfs` 中只向右和下扩展，没有考虑四个方向。
    
3. **初始化时，应该记录每个格子最早被砸的时间，而不是直接赋值。**  
    有可能同一个格子会被多个流星砸，应该取最早的时间。
    
4. **起点是否安全判断不完整：**  
    如果起点 `(0, 0)` 一开始就会在时刻 `0` 被摧毁，应该直接输出 `-1`。
    
5. **正确的 bfs 搜索条件是：当前时间必须小于该格子被砸的时间，或者这个格子永远不会被砸。**

### 解
```cpp
const int MAXN = 305;
const int INF = 1e9;

int g[MAXN][MAXN];
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

struct Node {
    int x, y, t;
};

void bfs() {
    queue<Node> q;
    vector<vector<bool>> vis(MAXN, vector<bool>(MAXN, false));

    if (g[0][0] == 0) { // 起点已被砸
        cout << -1 << '\n';
        return;
    }

    q.push({0, 0, 0});
    vis[0][0] = true;

    while (!q.empty()) {
        auto [x, y, t] = q.front(); q.pop();

        if (g[x][y] == INF) { // 找到永远不会被砸的安全区
            cout << t << '\n';
            return;
        }

        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            int nt = t + 1;

            if (nx < 0 || ny < 0 || nx >= MAXN || ny >= MAXN)
                continue;

            if (vis[nx][ny])
                continue;

            if (nt >= g[nx][ny]) // 到达时格子已经被砸，不可走
                continue;

            vis[nx][ny] = true;
            q.push({nx, ny, nt});
        }
    }
    cout << -1 << '\n'; // 无法到达安全区
}

int main() {
    int M;
    cin >> M;

    for (int i = 0; i < MAXN; ++i)
        for (int j = 0; j < MAXN; ++j)
            g[i][j] = INF;

    for (int i = 0; i < M; ++i) {
        int X, Y, T;
        cin >> X >> Y >> T;

        if (T < g[X][Y])
            g[X][Y] = T;

        for (int d = 0; d < 4; ++d) {
            int nx = X + dx[d];
            int ny = Y + dy[d];
            if (nx >= 0 && ny >= 0 && nx < MAXN && ny < MAXN)
                if (T < g[nx][ny])
                    g[nx][ny] = T;
        }
    }

    bfs();
    return 0;
}
```