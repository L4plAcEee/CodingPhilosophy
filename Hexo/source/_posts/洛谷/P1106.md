## Daily::算法 @[P1106 删数问题](https://www.luogu.com.cn/problem/P1106)
### 思路
贪心策略：
~~删除 K 次，每次都尽可能删除 数位上数字较大的。 ~~
只过了3/7的点 似乎不对捏
是不是排序破坏了顺序？
要不直接暴力模拟 K 次删除？

还是错了，看来贪心策略有问题。

### 勘误
这个代码有一个关键的逻辑错误。你的算法是每次删除**最大的数字**，但这并不能保证得到最小的结果。

让我们用例子来说明问题：

- 输入：`175438`，删除4个数字
- 你的算法：每次删除最大值 8→7→5→4，剩下 `13`
- 看起来结果正确，但这只是巧合

**真正的问题**：考虑输入 `54321`，删除2个数字

- 你的算法：删除5→4，得到 `321`
- 正确答案：删除5→4，得到 `321`（这个例子碰巧对了）

再考虑 `1432219`，删除3个数字：

- 你的算法：删除4→3→2，得到 `1219`
- 正确算法：应该从左到右贪心，得到更小的结果

**正确的贪心策略**： 从左到右扫描，如果当前数字比下一个数字大，就删除当前数字。这样可以保证高位尽可能小。

### 解
**算法核心思想**：

1. **贪心策略**：从左到右找第一个比下一位大的数字并删除它
2. **为什么这样做**：删除一个"峰值"数字可以让整个数变小，且影响高位
3. **边界情况**：如果数字是递增的（如12345），就删除最后一个数字

**时间复杂度分析**：

- 方法1：O(k × n)，对于每次删除都要扫描一遍
- 方法2：O(n)，使用栈只需要一次遍历

```cpp
int main() {
    string n;
    int k;
    cin >> n >> k;
    
    // 方法1：逐个删除（简单易懂）
    string result = n;
    for (int times = 0; times < k; times++) {
        int pos = -1;
        for (int i = 0; i < result.length() - 1; i++) {
            if (result[i] > result[i + 1]) {
                pos = i;
                break;
            }
        }
        if (pos == -1) {
            pos = result.length() - 1;
        }
        result.erase(pos, 1);
    }
    
    // 处理前导零
    int start = 0;
    while (start < result.length() && result[start] == '0') {
        start++;
    }
    
    if (start == result.length()) {
        cout << "0" << endl;
    } else {
        cout << result.substr(start) << endl;
    }
    
    return 0;
}

/* 
// 方法2：使用栈优化（更高效）
#include <bits/stdc++.h>
using namespace std;

int main() {
    string n;
    int k;
    cin >> n >> k;
    
    string stack;
    int toRemove = k;
    
    for (char digit : n) {
        // 当栈不为空，还需要删除数字，且栈顶比当前数字大时
        while (!stack.empty() && toRemove > 0 && stack.back() > digit) {
            stack.pop_back();
            toRemove--;
        }
        stack.push_back(digit);
    }
    
    // 如果还需要删除数字，从末尾删除
    while (toRemove > 0) {
        stack.pop_back();
        toRemove--;
    }
    
    // 处理前导零
    int start = 0;
    while (start < stack.length() && stack[start] == '0') {
        start++;
    }
    
    if (start == stack.length()) {
        cout << "0" << endl;
    } else {
        cout << stack.substr(start) << endl;
    }
    
    return 0;
}
*/
```

