---
笔记: 2025-06-18
属性:
  - <搜索Search>
  - <状态压缩DP>
  - <旅行商问题TSP>
tags:
  - 题解
---
## [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)
### 思路
~~朴素思路就是，每次选择一个最近的点，
对于 $1≤n≤15$ 的规模估计够用。~~

### 勘误
你当前写的代码是一个**贪心算法**，每次都选离当前位置最近的奶酪。这个做法 **并不能保证最优解**，因为这实际上是一个**旅行商问题（TSP，Travelling Salesman Problem）**，贪心解法会得到一个次优解。

题目要求的是**至少要跑的距离**，因此必须使用**状态压缩动态规划（DP + Bitmask）**，才能正确解决这个问题。

#### 解题思路
****
- 状态：`dp[s][i]` 表示当前已经吃掉的奶酪集合为 `s`，且当前停留在第 `i` 个奶酪位置时的最小距离。
    
- 转移：从已经吃过的奶酪 `j` 转移到当前奶酪 `i`：
$$
dp[s][i] = \min_{j \in s, \, j \neq i} \left( dp[s \setminus \{i\}][j] + \text{dis}(j, i) \right)
$$
- 初始状态：从原点 $(0, 0)$ 出发，到第 `i` 个奶酪的距离。
    
- 最终答案：所有状态全部吃完后，最后一次到达任意一个奶酪的最小值。

### 解
- 本题是典型的**状态压缩DP + TSP**模型，贪心法不能保证最优解。
    
- 核心状态设计：`dp[s][i]`。
    
- 状态个数：$O(2^n \times n)$，复杂度可以接受。
```cpp
using f64 = double;
const int N = 20;
const int INF = 1 << 30;

int n;
f64 dp[1 << N][N];  // 状态压缩DP
f64 dis[N][N];      // 距离矩阵
pair<f64, f64> a[N];

f64 get_distance(pair<f64, f64> p1, pair<f64, f64> p2) {
    return sqrt(pow(p1.first - p2.first, 2) + pow(p1.second - p2.second, 2));
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> a[i].first >> a[i].second;
    }

    // 预处理距离
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            dis[i][j] = get_distance(a[i], a[j]);

    // 初始化
    for (int i = 0; i < (1 << n); ++i)
        for (int j = 0; j < n; ++j)
            dp[i][j] = 1e9;

    // 起点到各个点的距离
    for (int i = 0; i < n; ++i)
        dp[1 << i][i] = get_distance({0.0, 0.0}, a[i]);

    // 状态转移
    for (int s = 1; s < (1 << n); ++s) {
        for (int i = 0; i < n; ++i) {
            if (!(s & (1 << i))) continue; // 如果 i 不在当前集合里，跳过
            for (int j = 0; j < n; ++j) {
                if (i == j || !(s & (1 << j))) continue; // j 不在集合里
                dp[s][i] = min(dp[s][i], dp[s ^ (1 << i)][j] + dis[j][i]);
            }
        }
    }

    f64 ans = 1e9;
    int full = (1 << n) - 1;

    // 最小答案
    for (int i = 0; i < n; ++i) {
        ans = min(ans, dp[full][i]);
    }

    cout << fixed << setprecision(2) << ans << '\n';

    return 0;
}
```