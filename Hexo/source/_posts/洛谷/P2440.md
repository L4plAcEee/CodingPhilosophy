## Daily::算法 @[P2440 木材加工](https://www.luogu.com.cn/problem/P2440)
> 要保护环境喵
### 思路
> 对于 100% 的数据，有 $1≤n≤10^5，1≤k≤10^8，1≤L_i​≤10^8(i∈[1,n])$。

-> 分析数据规模，应该需要 $n * log(n)$ 的算法

> 木材厂有 n 根原木，现在想把这些木头切割成 k 段长度**均**为 l 的小段木头（木头有可能有剩余）。当然，我们希望得到的小段木头越长越好，请求出 l 的最大值。

看起来是 二分答案 ，但是如何构建答案的单调性呢？

![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/adc4202391aac77ab963e3b3ace1a1b0_MD5.jpeg)

### 解
过了，不过其中有个小问题导致爆了RE
就是check 传入 0 的时候 会导致 除以0 的异常。
所以要在开头过滤一下。

#### 代码
```cpp
const int MAXN = 1e5 + 5;


int n, k, a[MAXN];

bool check(int len) {
    if (len == 0) return true;
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += a[i] / len;
        if (ans >= k) return true;
    }
    return false;
}

int32_t main() {
    cin >> n >> k;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
    }
    sort(a, a + n);
    int l = 0, r = 1e8;
    while (l <= r) {
        int mid = (r - l) / 2 + l;
        if (check(mid)) {
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    cout << r << '\n';
}
```

---
