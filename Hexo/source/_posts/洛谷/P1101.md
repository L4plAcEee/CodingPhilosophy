---
笔记: 2025-06-25
摘要: 
tags:
  - "#题解"
---
## [P1101 单词方阵](https://www.luogu.com.cn/problem/P1101)
### 思路
~~遍历矩阵然后 向八个方向进行dfs 然后匹配串。~~
又会错题意了，题目只是要求斜向竖向和横向这几种摆放情况，
还就那个想太多。
还就那个越简单越难。
### 你的代码存在的问题与修改建议

你的思路整体是正确的：对每个位置 `(i, j)` 作为起点，尝试递归匹配 `yizhong`，并标记匹配位置。但存在几个关键问题会导致程序运行失败或输出错误。

---

### ❗关键错误：赋值运算符误用

```cpp
if (idx = pattern.length() - 1) return true;
```

这里应使用 **比较运算符** ` == `，而非赋值 ` = `。这一行会导致逻辑恒为 `true`，返回错误结果。

#### ✅ 正确写法：

```cpp
if (idx == pattern.length() - 1) return true;
```

---

#### ⚠逻辑问题：多方向递归无记忆化会污染状态

你对每个方向都直接递归了所有方向，导致方向不固定、状态不可控。应该在找到起点后，固定方向进行 `7` 步尝试，而不是在递归中变方向。

---

#### ✅ 改进建议：使用方向一致的遍历替代 DFS

重构思路如下：

1. 对每个位置 `(i,j)` 和每个方向 `d`，尝试从该点起是否存在完整的 `yizhong`。
    
2. 如果存在，记录路径上的所有点。
    
3. 最后统一输出。
    
### 解
```cpp
const int MAXN = 101;
char mat[MAXN][MAXN];
bool vis[MAXN][MAXN]; // 标记最终匹配成功的位置
int n;
string pattern = "yizhong";

int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};
int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};

void check(int x, int y, int dir) {
    for (int i = 0; i < pattern.size(); ++i) {
        int nx = x + dx[dir] * i;
        int ny = y + dy[dir] * i;
        if (nx < 0 || nx >= n || ny < 0 || ny >= n) return;
        if (mat[nx][ny] != pattern[i]) return;
    }

    for (int i = 0; i < pattern.size(); ++i) {
        int nx = x + dx[dir] * i;
        int ny = y + dy[dir] * i;
        vis[nx][ny] = true;
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            cin >> mat[i][j];

    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            for (int d = 0; d < 8; ++d)
                check(i, j, d);

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j)
            cout << (vis[i][j] ? mat[i][j] : '*');
        cout << '\n';
    }
    return 0;
}
```