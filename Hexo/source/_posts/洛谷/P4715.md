---
笔记: 2025-06-28
摘要: 
tags:
  - 题解
  - 高价值
---
## [P4715 【深基16.例1】淘汰赛](https://www.luogu.com.cn/problem/P4715)
### 思路
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/535c7eba884c555be59aedfe281ebcba_MD5.jpeg)
 > 相当于知道叶子还原按照规则生成树，所以选择后序遍历（可以先拿到双子节点的信息，从而影响当前节点的决策）。然后返回根的较小的子节点。

### 解
```cpp
const int MAXN = 7;
int n;
int a[1 + (1 << MAXN)]; // 能力值，下标从1开始
int node_val[1 << (MAXN + 1)]; // 每个节点存储胜者的编号

// 递归建树，返回当前节点的胜者编号
int build_tree(int id, int l, int r) {
    if (l == r) {
        node_val[id] = l; // 叶子节点存国家编号
        return node_val[id];
    }
    int mid = (l + r) / 2;
    int left = build_tree(id * 2, l, mid);
    int right = build_tree(id * 2 + 1, mid + 1, r);

    // 比较能力值，选出胜者编号
    node_val[id] = (a[left] > a[right] ? left : right);
    return node_val[id];
}

int main() {
    cin >> n;
    int total = 1 << n;

    for (int i = 1; i <= total; ++i)
        cin >> a[i];

    int champion = build_tree(1, 1, total); // 构建树并得到冠军编号

    // 亚军是倒数第二场的败者，即根节点两个子树中落败的那个
    int left = node_val[2], right = node_val[3];
    int runner_up = (a[left] > a[right] ? right : left);

    cout << runner_up << endl;
    return 0;
}
```

### Q&A
#### l r 变量是用来确定叶子节点的是吗？
>是的，`l` 和 `r` 的作用就是用于**确定叶子节点范围**的，更具体地说：

你写的函数 `build_tree(id, l, r)` 中：

- `l` 是当前子树处理的国家编号区间的左端点；
    
- `r` 是右端点；
    
- 当 `l == r` 时，说明这个子树只负责一个国家编号，也就是说它是一个**叶子节点**，不再递归分裂。
    

淘汰赛的本质是**把一段编号区间两两配对递归处理**，你可以想象如下比赛区间划分（8 个国家）：

```
编号：1 2 3 4 5 6 7 8
区间：|-----左半-----|-----右半-----|
           |--------总区间--------|
```

你传递 `(l, r)` 的作用就是每次把比赛区间对半切，然后继续分治：

- `build_tree(id, 1, 8)` → 切成 `(1,4)` 和 `(5,8)`
    
- 然后再递归分别切成 `(1,2),(3,4)` 和 `(5,6),(7,8)`...
    
- 一直到 `l==r`，即处理单个国家。