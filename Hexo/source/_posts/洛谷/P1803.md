## Daily::算法 @[P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
### 思路
实际上就是区间覆盖问题、兽栏问题...etc
~~所以，思路上来说的话：~~
~~先对区间左端点排序（从小到大），然后从左到右扫描就行。~~
~~实现上来说的话：~~
~~如果下一个 进入段 的左端点 小于 当前块 的右端点，则延长当前块的右端点为进入段的右端点；
如果下一个 进入段 的左端点 大于或等于 当前块 的右端点，则结束统计旧块，将该 进入段 作为 新块，并计数加一；~~

遍历排序后的数组，然后每次跳到下一个不重合的区间并计数。

### 勘误
- 按 “开始时间” 升序排序，这种排序下的贪心选择并不能保证最优（因为有可能先选了一个更早开始但持续时间特别长的比赛，反而错过了之后能容下更多短小比赛的机会）。
    
- 按结束时间升序排序的直观理由：若我们总是取最早结束的、且与已选比赛不冲突的比赛，那么之后留给其余比赛的“可用时间”最大。

### 解
- 排序关键在于 `a.right < b.right`。
    
- 贪心选择条件是 `r[i].left ≥ last_end`。
    
- 这样能确保已选比赛之间严格不重叠，且场次最多。
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Range {
    int left;
    int right;
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<Range> r(n);
    for (int i = 0; i < n; ++i) {
        cin >> r[i].left >> r[i].right;
    }
    // 按照结束时间升序排序
    sort(r.begin(), r.end(), [](const Range &a, const Range &b) {
        if (a.right == b.right) 
            return a.left < b.left;  // 结束时间相同，次要按开始时间升序
        return a.right < b.right;
    });

    int cnt = 0;
    int last_end = -1;  // 上一次选择的比赛结束时间，初始设为 -1（或更小都行）

    for (int i = 0; i < n; ++i) {
        if (r[i].left >= last_end) {
            // 可以选择这场比赛
            cnt++;
            last_end = r[i].right;
        }
    }

    cout << cnt << "\n";
    return 0;
}
```

