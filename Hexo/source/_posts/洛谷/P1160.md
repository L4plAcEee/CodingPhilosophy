## Daily::算法 @[P1160 队列安排](https://www.luogu.com.cn/training/113#problems)
> 对于 100% 的数据，$1<M≤N≤10^5$。

数据弱的话，直接erase应该能过。

当然，这道题应该是要拿链表模拟人排队，但是并不需要真的写链表，
可以用静态数组模拟跳转结构。
### 勘误
#### 边界条件
**原来的题解之所以出现错误，主要原因正是没有处理“重复删除同一个人”的情况**。这是一个**易被忽略但致命的边界条件**。

在你的原始代码中，删除操作如下所示：
```cpp
int pre_v = pre[tg], nxt_v = nxt[tg];
nxt[pre_v] = nxt_v;
pre[nxt_v] = pre_v;
pre[tg] = 0;
nxt[tg] = 0;
```
这段代码默认：

1. `tg` 还在链表中；
    
2. `pre[tg]` 和 `nxt[tg]` 都是有效的邻接节点。
👉 然而，**题目中明确指出：如果某个同学已经不在队列中，忽略此操作**。

#### 在**插入操作**里这段代码有逻辑错误
你原代码是：
```cpp
if (op == 1) {
    int tmp = nxt[tg];
    nxt[i] = tmp;
    pre[i] = i;
    nxt[tg] = i;
    pre[tmp] = i;
}

```
写了 `pre[i] = i` 和 `nxt[i] = i`，这是完全错误的。
### 解
```cpp
const int MAXN = 1e5 + 5;
int n, m, nxt[MAXN] = {0}, pre[MAXN] = {0};

int main() {
    cin >> n;
    nxt[0] = 1;
    for (int i = 2; i <= n; ++i) {
        int tg = -1, op = -1;
        cin >> tg >> op;
        if (op == 1) {
            int tmp = nxt[tg];
            nxt[tg] = i;
            pre[i] = tg;
            nxt[i] = tmp;
            pre[tmp] = i;
        } else {
            int tmp = pre[tg];
            nxt[i] = tg;
            pre[i] = tmp;
            nxt[tmp] = i;
            pre[tg] = i;
        }
    }

    int m;
    cin >> m;
    while (m--) {
        int tg = -1;
        cin >> tg;
        int pre_v = pre[tg], nxt_v = nxt[tg];
        if (pre_v == 0 && nxt_v == 0) continue;
        nxt[pre_v] = nxt_v;
        pre[nxt_v] = pre_v;
        pre[tg] = 0;
        nxt[tg] = 0;
    }

    int head = 0;
    while (nxt[head]) {
        head = nxt[head];
        cout << head << ' ';
    }
}
```

---
