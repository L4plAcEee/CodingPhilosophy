---
date: "2025-06-10"
---
## [P1241 括号序列](https://www.luogu.com.cn/problem/P1241)
### 思路

按题目要求标记 失配元素 并缓存
然后遍历缓存构造 答案串

### 勘误
你这个代码整体思路正确，但测试点 8、9、10、11 全部 **WA（Wrong Answer）**，说明代码存在**遗漏情况**。

根据你给出的错误信息，问题集中在：

- 当栈顶是一个左括号，但是类型不匹配时，应该直接加入当前右括号所需的配对（而你现在的做法是简单跳过，不处理该右括号）。
    

#### 重点：

你当前代码逻辑是：

```cpp
if (stk.empty() || s[i] != get_another(s[stk.top()])) {
    stk.push(i);
} else {
    stk.pop();
}
```

这个写法 **错误处理了不匹配的右括号情况。**

实际上：

- 遇到右括号时，如果**无法配对**，这个右括号也应该标记为需要补充的（它自身无法匹配）。
    

但是你现在的写法会直接跳过，导致这个右括号在答案里被原样保留，进而出现格式不对。

#### 正确做法：

1. 如果当前是左括号，直接入栈。
    
2. 如果当前是右括号：
    
    - 栈非空，且栈顶类型匹配：配对，弹栈。
        
    - 栈空，或者栈顶类型不匹配：当前右括号视为无法配对，标记需要补充。
        

#### 修改后的核心循环：

```cpp
for (int i = 0; i < s.length(); ++i) {
    if (s[i] == '(' || s[i] == '[') {
        stk.push(i);
    } else {
        if (!stk.empty() && s[stk.top()] == get_another(s[i])) {
            stk.pop(); // 成功配对
        } else {
            memo[i] = true; // 无法配对，当前右括号需要补充
        }
    }
}
```

#### 核心改动总结：

- 遇到**不匹配的右括号**，也要标记补充（你之前漏处理了）。
    
- 题目强调的是：不管左括号还是右括号，**都要配对**，不能跳过。

### 解
```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
bool memo[101] = {false};

char get_another(char c) {
    if (c == '(') return ')';
    if (c == ')') return '(';
    if (c == '[') return ']';
    if (c == ']') return '[';
    return ' ';
}

int main() {
    cin >> s;
    stack<int> stk;
    for (int i = 0; i < s.length(); ++i) {
        if (s[i] == '(' || s[i] == '[') {
            stk.push(i);
        } else {
            if (!stk.empty() && s[stk.top()] == get_another(s[i])) {
                stk.pop(); // 成功配对
            } else {
                memo[i] = true; // 无法配对的右括号
            }
        }
    }
    while (!stk.empty()) {
        memo[stk.top()] = true; // 未配对的左括号
        stk.pop();
    }
    string ans;
    for (int i = 0; i < s.length(); ++i) {
        if (memo[i]) {
            if (s[i] == '(') ans += "()";
            else if (s[i] == ')') ans += "()";
            else if (s[i] == '[') ans += "[]";
            else if (s[i] == ']') ans += "[]";
        } else {
            ans += s[i];
        }
    }
    cout << ans << '\n';
}
```

---