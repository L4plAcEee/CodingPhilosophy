## Daily::算法 @[P1464 Function](https://www.luogu.com.cn/problem/P1464)
### 题目描述

对于一个递归函数 w(a,b,c)

- 如果 a≤0 或 b≤0 或 c≤0 就返回值 1。
- 如果 a>20 或 b>20 或 c>20 就返回 w(20,20,20)
- 如果 a<b 并且 b<c 就返回 w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)。
- 其它的情况就返回 w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)

这是个简单的递归函数，但实现起来可能会有些问题。当 a,b,c 均为 15 时，调用的次数将非常的多。你要想个办法才行。

注意：例如 w(30,−1,0) 又满足条件 1 又满足条件 2，请按照最上面的条件来算，答案为 1。

### 思路#0 <朴素DFS>
直接按照题目要求写，尝尝咸淡。
时间复杂度那肯定是爆炸的，只是尝试格式过关就行。

#### 关键代码
```cpp
int w(int a, int b, int c) {
    if (a <= 0 || b <= 0 || c<= 0) return 1;
    if (a > 20 || b > 20 || c > 20) return w(20, 20, 20);
    if (a < b && b < c) return w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);
    return w(a - 1, b , c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1);
}
```

### 思路#1 <记忆化DFS> <-AC
普通dfs肯定爆炸，题目也明确要求我们优化
> 这是个简单的递归函数，但实现起来可能会有些问题。当 a,b,c 均为 15 时，调用的次数将非常的多。你要想个办法才行。

注意到：
> 如果 a>20 或 b>20 或 c>20 就返回 w(20,20,20）

所以开 21 的 三维数组辅助就够了
```cpp
int memo[MAXN][MAXN][MAXN] = {-1};
```

#### Mistake
##### 1. 函数调用错误
在你定义的 `w2()` 中，函数体内部调用的是 `w(...)` 而不是 `w2(...)`，例如：
`return w(a, b, c - 1) + w(a, b - 1, c - 1) - w(a, b - 1, c);`

> 复制过来忘记改了md

##### 2. 初始化方式错误
`int memo[MAXN][MAXN][MAXN] = {-1};`

这个初始化语法只会将 `memo[0][0][0] = -1`，其余其余元素仍然是未定义值（未必是 -1）。正确初始化整个数组的方法如下：
- 如果使用 C++，推荐使用 `memset`：
	`memset(memo, -1, sizeof(memo));`
- 或者使用 `std::vector` 和构造函数初始化：
	`vector<vector<vector<int>>> memo(MAXN, vector<vector<int>>(MAXN, vector<int>(MAXN, -1)));`

#### 关键代码
```cpp
int w2(int a, int b, int c) {
    if (a <= 0 || b <= 0 || c <= 0) return 1;
    if (a > 20 || b > 20 || c > 20) return w2(20, 20, 20);
    if (memo[a][b][c] != -1) return memo[a][b][c];
    if (a < b && b < c)
        return memo[a][b][c] = w2(a, b, c - 1) + w2(a, b - 1, c - 1) - w2(a, b - 1, c);
    return memo[a][b][c] = w2(a - 1, b, c) + w2(a - 1, b - 1, c) + w2(a - 1, b, c - 1) - w2(a - 1, b - 1, c - 1);
}
```

#### 关键点
注意不要复制过来忘记改函数名了 ：-（
不然debug半天

### 思路#2 <动态规划> <-AC
有了记忆化DFS解那肯定要想想DP嘛。
分析一下题目：
	状态决定参数：a， b， c
	BaseCase：当 a <= 0 || b <= 0 || C <= 0 时 返回 1
	约束：
		1. 如果 a>20 || b>20 || c>20 时返回 w(20,20,20) （只是作为限制的约束）
		2. 如果 a<b 并且 b<c 就返回 w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)。
		3. 其它的情况就返回 w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)

即 每个状态 依赖
`dp[i][j][k]`
-> `dp[a][b][c - 1] + dp[a][b - 1] - dp[a][b - 1][c]` (当 a<b 并且 b<c)
-> `dp[a - 1][b][c] + dp[a - 1][b - 1][c] + dp[a - 1][b][c - 1] - dp[a - 1][b - 1][c - 1]`（Common Senses）

#### 关键代码
```cpp
int dp_table[MAXN][MAXN][MAXN];

void dp() {
    for (int i = 0; i < MAXN; ++i) {
        for (int j = 0; j < MAXN; ++j) {
            for (int k = 0; k < MAXN; ++k) {
                if (i == 0 || j == 0 || k == 0) {
                    dp_table[i][j][k] = 1;
                } else if (i < j && j < k) {
                    dp_table[i][j][k] = dp_table[i][j][k - 1] + dp_table[i][j - 1][k - 1] - dp_table[i][j - 1][k];
                } else {
                    dp_table[i][j][k] = dp_table[i - 1][j][k]
                                      + dp_table[i - 1][j - 1][k]
                                      + dp_table[i - 1][j][k - 1]
                                      - dp_table[i - 1][j - 1][k - 1];
                }
            }
        }
    }
}
```

---
