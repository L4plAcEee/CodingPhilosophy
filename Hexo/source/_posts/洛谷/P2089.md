## Daily::算法 @[P2089 烤鸡](https://www.luogu.com.cn/problem/P2089)
### 题目描述
猪猪 Hanke 得到了一只鸡。
猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 10 种配料（芥末、孜然等），每种配料可以放 1 到 3 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 n ，请输出这 10 种配料的所有搭配方案。

输入格式：
	一个正整数 n，表示美味程度。

输出格式：
	第一行，方案总数。
	第二行至结束，10 个数，表示每种配料所放的质量，按字典序排列。
	如果没有符合要求的方法，就只要在第一行输出一个 0。
> 对于 100% 的数据，$n≤5000$

### 思路
枚举所有可能

### 提交#1 <-AC
#### 关键代码
```cpp
// 当前配料编号、第 i 个配料，和当前总克数 deli
void dfs(vector<int>& path, int idx, int deli) {
    if (idx == 10) { // 已经放了10种配料
        if (deli == n) ans.push_back(path); // 总克数恰好为 n，合法方案
        return;
    }
    for (int j = 1; j <= 3; ++j) { // 每种配料可以放1到3克
        path.push_back(j);
        dfs(path, idx + 1, deli + j); // 放下一种配料
        path.pop_back();
    }
}
```
#### 关键点
**关键问题**：  
你在 `dfs` 里用了两层循环：
`for (int i = 0; i < 10; ++i) {      for (int j = 1; j <= 3; ++j) {         ...     } }`
**但实际上**，应该是严格按照“**每种配料（共10种），每种放1到3克**”，**每种只放一次**，而不是每次随便放 1 到 3 克还循环10次！
- 也就是说，**搜索10次（恰好10个配料）**，每次选择当前配料放 1、2、3 克。
- 当前递归深度（配料编号）应从0到9，而不是乱循环。

### 优化
可以优化的点：
1. **剪枝优化**：如果`当前剩余最小值 > 还能放的量`，可以提前返回（但这题数据范围小，不需要剪枝也能过）。
2. **时间复杂度**：最多 3103^{10}310 次搜索，约59000次以内，**可以承受**。

---
