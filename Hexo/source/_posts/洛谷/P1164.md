## Daily::算法 @[P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)
### 题目描述
uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。

不过 uim 由于买了一些书，口袋里只剩 M 元 $(M≤10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N≤100)$，第 i 种卖 $a_i​$ 元 $(a_i​≤1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 1 秒。

### 思路#0
~~<DP - 0-1背包问题模型>~~
~~定义dp数组：
	`dp[i][j]` 为 在 花费 j 元 的情况下，选择前 i 个物品的最大点菜方法。
定义状态转移：
	1. 不选择第 i 个物品：`dp[i][j] = dp[i - 1][j]`
	2. 选择第 i 个物品：`dp[i][j] = dp[i - 1][j - cost[i] + 1`~~

<DP - 变种0-1背包>
典型的 **0/1 背包问题求“恰好凑出目标和的方案数”** 的变种，**但也实现错误**，你返回的是“最多能选几道菜”，并非题目要求的“有多少种选菜方案”。

目标是：从 `N` 个数中，选若干个 **互不相同** 的数，使其和恰好为 `M`，问有多少种方案。
定义状态：  
	`dp[i][j]` 表示前 `i` 个菜中，花费为 `j` 的选法数量。

递推公式：
- 不选第 `i` 个菜：`dp[i][j] += dp[i-1][j]`
- 选第 `i` 个菜（若 `j >= cost[i]`）：`dp[i][j] += dp[i-1][j - cost[i]]`

#### 提交#0 <-WA
过了一个点，其他全WA了。
什么情况？
下个数据看看
```in
10 9
1 2 3 4 5 6 7 8 9 10
```

```out
我的输出：3
正解：8
```
dp定义错了？应该不是
应该是状态转移错了？


### 提交#1 <-AC
#### 关键代码
**普通版本**
```cpp
dp[0][0] = 1; // 什么都不选，总价为 0 的方案为 1 种

for (int i = 1; i <= N; ++i) {
	for (int j = 0; j <= M; ++j) {
		// 不选第 i 个菜
		dp[i][j] = dp[i - 1][j];
		// 选第 i 个菜
		if (j >= cost[i]) {
			dp[i][j] += dp[i - 1][j - cost[i]];
		}
	}
}
```

**空间压缩**
```cpp
dp[0] = 1;
for (int i = 1; i <= N; ++i) {
	for (int j = M; j >= cost[i]; --j) {
		dp[j] += dp[j - cost[i]];
	}
}
```

#### 关键点
变种0-1背包别写成了经典0-1背包了



---
