## Daily::算法 @[P1259 黑白棋子的移动](https://www.luogu.com.cn/problem/P1259)
### 题目描述

有 2n 个棋子排成一行，开始为位置白子全部在左边，黑子全部在右边，如下图为 n=5 的情况：

![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/b865688c506ad120c1a59f3424c119b6_MD5.png)

移动棋子的规则是：每次必须同时移动相邻的两个棋子，颜色不限，可以左移也可以右移到空位上去，但不能调换两个棋子的左右位置。每次移动必须跳过若干个棋子（不能平移），要求最后能移成黑白相间的一行棋子。如 n=5 时，成为：

![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/065acbc8a45410b63250bfd116b73c32_MD5.png)

任务：编程打印出移动过程。

> $4≤n≤100$

### 思路#0
使用回溯进行简单模拟？
考虑题目规则：
1. 每次必须同时移动相邻的两个棋子，颜色不限，可以左移也可以右移到空位上去，但不能调换两个棋子的左右位置。
2. 每次移动必须跳过若干个棋子（不能平移），要求最后能移成黑白相间的一行棋子。

观察样例输出#1 实际上也确实就是模拟。
而且很明显边界条件就是：空位`--`到达开头
所以我们只需要分区即可：
`[...未处理...][...空位...]`
->`[...未处理...][...空位...][...已处理...]`
-> ...
->`[...空位...][...已处理...]`
然后当空位来到开头，即未处理区间全部处理完，结束递归。

#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
string s;

void change(int from, int to) {
    swap(s[from], s[to]);
    swap(s[from + 1], s[to + 1]);
    cout << s << '\n';
}
 
void f(int idx) {
  if (idx == 8) {
        change(8, 3);
        change(3, 7);
        change(7, 1);
        change(1, 6);
        change(6, 0);
        return;
    }
    
    int half = idx / 2 - 1;
    change(half, idx);
    idx -= 2;
    change(half, idx);
    f(idx);
}

int32_t main() {
    cin >> n;
    s += string(n, 'o');
    s += string(n, '*');
    s += "--";
    cout << s << '\n';
    f(2 * n);
}
```

#### 关键点
1. 当 N 来到 4 即 idx 来到 8 来到边界情况，需要特殊处理
2. 不要忘了开头输出一下原串

---
