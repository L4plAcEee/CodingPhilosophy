---
date: "2025-06-09"
---
## [P2058 [NOIP 2016 普及组] 海港](https://www.luogu.com.cn/problem/P2058)
### 思路
> 形式化地讲，你需要计算 n 条信息。对于输出的第 i 条信息，你需要统计满足 $t_i​−86400<t_p​≤t_i$​ 的船只 p，在所有的 xp,j​ 中，总共有多少个不同的数。

自定义数据结构 ship；
维护一个队列，入队节点需要保证 arrival time <= 队头节点 的 arrival time + 86400;
一旦新节点即将入队时，会导致队列非法，则弹出头节点，收割答案。

然后过程中维护一个 国籍 数组，记录此时当前队列状态的乘客国籍信息，当收割答案时，遍历 该数组 获取国籍异同信息，然后 去除失效节点的信息，维护合法性。

### 抄
开摆了
#### 勘误
你的代码已经接近完成，主要思路是使用队列维护一个 24 小时（86400 秒）的滑动窗口，同时用数组统计当前时间窗口内不同国家的数量。你遗漏的关键部分是 `clean()` 函数，它的职责是从队列中弹出超出时间窗口的船只，并同步减少国籍计数。

下面是完整代码补全和修正，包括：

- 定义 `船只信息` 数据结构；
    
- 正确实现 `clean()` 函数；
    
- 每艘船处理后及时输出当前统计的不同国家数量。
#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int DAY_TIME = 86400;
const int MAXK = 3e5 + 1;
const int MAXN = 1e5 + 1;

int n;
int passage[MAXK] = {0};  // 国籍计数
int diff_cnt = 0;         // 当前不重复的国家数

// 每艘船的数据：到达时间 + 乘客国籍列表
struct Ship {
    int time;
    vector<int> passengers;
};

queue<Ship> q;

void clean(int current_time) {
    // 将超过24小时的船只弹出队列
    while (!q.empty() && q.front().time <= current_time - DAY_TIME) {
        for (int x : q.front().passengers) {
            passage[x]--;
            if (passage[x] == 0) {
                diff_cnt--;
            }
        }
        q.pop();
    }
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

    cin >> n;
    for (int i = 0; i < n; ++i) {
        int t, k, x;
        cin >> t >> k;
        vector<int> temp;
        for (int j = 0; j < k; ++j) {
            cin >> x;
            temp.push_back(x);
            if (passage[x] == 0) {
                diff_cnt++;
            }
            passage[x]++;
        }
        q.push({t, temp});
        clean(t);  // 清除超出24小时的船只
        cout << diff_cnt << "\n";
    }
    return 0;
}
```

---