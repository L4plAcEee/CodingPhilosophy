## Daily::算法 @[P1990 覆盖墙壁](https://www.luogu.com.cn/problem/P1990)
### 题目描述
你有一个长为 N 宽为 2 的墙壁，给你两种砖头：一个长 2 宽 1，另一个是 L 型覆盖 3 个单元的砖头。如下图：

```
0  0
0  00
```

砖头可以旋转，两种砖头可以无限制提供。你的任务是计算用这两种来覆盖 N×2 的墙壁的覆盖方法。例如一个 2×3 的墙可以有 5 种覆盖方法，如下：

```
012 002 011 001 011  
012 112 022 011 001
```

注意可以使用两种砖头混合起来覆盖，如 2×4 的墙可以这样覆盖：

```
0112
0012
```

给定 N，要求计算 2×N 的墙壁的覆盖方法。由于结果很大，所以只要求输出最后 4 位。例如 2×13 的覆盖方法为 13465，只需输出 3465 即可。如果答案少于 4 位，就直接输出就可以，不用加前导 0，如 N=3 时输出 5。
> 数据保证，1≤N≤1000000。

### ~~思路#0~~
#### <记忆化搜索>
这题的难点在于如何考虑dfs函数
也就是如何定义状态（分割子问题）
类似这种看似枚举的题目，可以先举出简单例子分析：
**N == 1**
只能用 `00` 砖头覆盖 即 方法数 == 1

**N == 2**
```
00 01
11 01 
```
方法数 == 2

**N == 3**
即题目示例，方法数 == 5

现在再回来思考一下定义状态的可变参数：
参数 i in $[0, N]$
`状态[i]` 代表 来到 长度 i 时，从 0~i区间 的墙壁覆盖方法数。

综合以上思考
现在有了basecase和可变参数，可以设计dfs了

`状态[i]` 来自 `状态[i - 1] + 1` or `状态[i - 2] + 2` or `状态[i - 3] + 5`

##### Mistake
<边界问题思考不完备>
	对 `memorize_dfs(i - 2)` 和 `memorize_dfs(i - 3)` 没有判断 `i < 2` 或 `i < 3` 的情况，可能会访问 `memo[-1]` 或 `memo[-2]`，导致未定义行为。

### ~~思路#1~~
#### <记忆化搜索> + <同余原理>
继续思考：
参数 $i = [0, N]$ `状态[i]` 代表 来到 长度 i 时，从 0~i区间 的墙壁覆盖方法数。
这个是正确的。
只是我的状态转移思考错了
实际上只要考虑，当来到i位置时，我选择什么砖头进行填充。
1. 如果选择 `L形砖头` 那么该选择的贡献就应该是：
```
001 011
011 001
```
$2×状态[i - 3]$
2. 如果选择 `-形砖头` 那么该选择的贡献应该是：
情况一： 
$状态[i-1] + 2 × 状态[i - 2]$

综合起来就是
$$
f(i) = f(i - 1) + 2f(i - 2) + 2f(i - 3),
f(0) = 1, f(1) = 1, f(2) = 2
$$
然后根据同余原理，直接 MOD 就行

### 正解
原因就在于**递推关系写错了** —— 你把所有对 “L 型砖” 贡献都叠加成了局部的 $2f(n-3)$，又把对 “2×1 砖” 的贡献翻倍成了 $2f(n-2)$，这与题意不符。

#### 正确的递推关系

令 $f(n)$ 为 $2\times n$ 墙的覆盖方案数，题目可得：

1. 先放一个竖直的 $2\times1$ 砖，剩下 $2\times (n-1)$：贡献 $f(n−1)$；
2. 先放两个水平的 $1\times2$ 砖，剩下 $2\times (n-2)$：贡献 $f(n−2)$；
3. 放一个 L 型砖（有两种镜像），它会“牵扯”到更早的所有状态：
   $$2\sum_{i=0}^{n-3} f(i).$$

合起来：

$$
\boxed{\,f(n)=f(n-1)+f(n-2)+2\sum_{i=0}^{n-3}f(i)\,}, \quad f(0)=1,\;f(1)=1,\;f(2)=2.
$$

因此，你需要把“对 n−3n-3 的局部贡献”替换成对所有更小状态的累积贡献，或者直接推导出等价的简化递推（例如用“前缀和”技巧把那个求和展开），才能得到正确答案。

#### 为什么？
![](https://l4p-bucket-1.oss-cn-shenzhen.aliyuncs.com/img/c7a0ee28ab6da5d358a026dab08acbb6_MD5.jpeg)

#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 1000001
#define MOD 10000
int N, prefix[MAXN];

int32_t main() {
    cin >> N;
    int dp[3];
    dp[0] = 1, dp[1] = 1, dp[2] = 2;
    prefix[0] = 1, prefix[1] = 2, prefix[2] = 4;
    for (int i = 3, cur; i <= N; ++i) {
        cur = (dp[2] + dp[1]+ 2 * prefix[i - 3]) % MOD;
        prefix[i] = (prefix[i - 1] + cur) % MOD;
        dp[0] = dp[1], dp[1] = dp[2], dp[2] = cur;
    }
    cout << dp[2] << '\n';
}
```

---

[^1]: 
