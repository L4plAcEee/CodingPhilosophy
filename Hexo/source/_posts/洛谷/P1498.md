## Daily::算法 @[P1498 南蛮图腾](https://www.luogu.com.cn/problem/P1498)
### 思路
> 数据保证，1≤n≤10。

~~应该是递归~~
是分治

### 抄（不会写喵）
这题是一个典型的**递归分形图案绘制题**。每一层图腾都是由上一层图腾构建而成，我们可以从输出样例中观察出图形的规律：

---

#### 🧠图形结构分析

以最小单位（也就是一棵“山”）为例：

```
 /\
/__\
```

从样例看出：

- 第 `n=1` 层图腾是一个小三角形。
    
- 第 `n=2` 层是在上一层的基础上，在其底部左右复制两个缩放后的子图腾。
    
- 图腾结构呈现二叉树状展开，整体高度为 $2^n$，宽度为 $2^{n+1}$。
    

---

#### 🧩 解决思路（递归画图）

我们使用一个二维字符数组 `canvas` 来模拟整幅图形，递归地从上往下绘制：

- 每个三角形的顶点坐标为 `(x, y)`，大小为 `level`。
    
- 若 `level == 1`，直接画出基本三角形。
    
- 否则，先在顶部画一个 `level-1` 的图腾，然后在底部左、右各画一个 `level-1` 的图腾。
    

---

#### ✅ C++ 实现代码如下：

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

const int MAX_N = 11;
const int MAX_H = 1 << MAX_N;      // 高度
const int MAX_W = (1 << (MAX_N + 1)); // 宽度

char canvas[MAX_H][MAX_W];

// 画三角形图腾，(x, y) 是顶点坐标，level 是层级
void draw(int x, int y, int level) {
    if (level == 1) {
        canvas[x][y] = '/';
        canvas[x][y + 1] = '\\';
        canvas[x + 1][y - 1] = '/';
        canvas[x + 1][y] = '_';
        canvas[x + 1][y + 1] = '_';
        canvas[x + 1][y + 2] = '\\';
        return;
    }
    int h = 1 << (level - 1); // 子图腾的高度
    // 顶部图腾
    draw(x, y, level - 1);
    // 左下图腾
    draw(x + h, y - h, level - 1);
    // 右下图腾
    draw(x + h, y + h, level - 1);
}

int main() {
    int n;
    cin >> n;

    int height = 1 << n;
    int width = 1 << (n + 1);

    // 初始化画布为空格
    for (int i = 0; i < height; ++i)
        for (int j = 0; j < width; ++j)
            canvas[i][j] = ' ';

    // 从顶点开始绘制整个图腾
    draw(0, width / 2 - 1, n);

    // 输出图腾
    for (int i = 0; i < height; ++i) {
        // 去掉右侧多余空格
        int right = width - 1;
        while (right >= 0 && canvas[i][right] == ' ') right--;
        for (int j = 0; j <= right; ++j)
            cout << canvas[i][j];
        cout << '\n';
    }

    return 0;
}
```

---

#### 💡备注与扩展
- 使用 `canvas[x][y]` 二维数组模拟图纸，可直接控制每一个字符的位置。
    
- 高度和宽度用 `2^n` 和 `2^(n+1)` 保证三角形结构不重叠。
    
- 递归画图中 `x + h`, `y ± h` 是关键位置变化。

---
