## [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
### 思路
bfs
### 勘误
你写的代码整体思路正确，但是你的 **BFS 步数统计方式有问题**。

你当前的写法是错误的，因为 `depth++` 是在处理队列每个节点的时候递增的，这样实际上统计的是经过的节点数量，不是按“层”递增的 BFS 最短路径。

核心问题：

- BFS 统计步数必须按 **层级推进**，也就是一层一层走。


## 正确写法：

应该在 BFS 中用 `while (size--)` 遍历当前层，走完当前层再递增步数。
### 解
```cpp
const int MAXN = 201;
int N, A, B, arr[MAXN];
bool visited[MAXN] = {false};

void bfs() {
    queue<int> q;
    q.push(A);
    visited[A] = true;
    int depth = 0;

    while (!q.empty()) {
        int size = q.size(); // 当前层节点个数
        while (size--) {
            int cur = q.front(); q.pop();
            if (cur == B) { // 找到目标
                cout << depth << '\n';
                return;
            }

            int n = cur - arr[cur];
            if (n >= 1 && n <= N && !visited[n]) {
                visited[n] = true;
                q.push(n);
            }

            n = cur + arr[cur];
            if (n >= 1 && n <= N && !visited[n]) {
                visited[n] = true;
                q.push(n);
            }
        }
        depth++; // 每遍历完一层，步数加 1
    }

    cout << -1 << '\n'; // 找不到目标
}

int main() {
    cin >> N >> A >> B;
    for (int i = 1; i <= N; ++i) {
        cin >> arr[i];
    }
    bfs();
}
```