## Daily::算法#1 @[P1152 欢乐的跳](https://www.luogu.com.cn/problem/P1152)
### 题目描述
一个 n 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n−1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 ${1,4,2,3}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。

给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。

每组测试数据第一行以一个整数 $n(1≤n≤1000)$ 开始，接下来 $n$ 个空格隔开的在 $[−10^8,10^8]$ 之间的整数。

对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 `Jolly`，否则输出 `Not jolly`。

### 思路
因为 $n$ 不大，先按题目思路走，构造对应的差值集合（静态数组模拟），
然后排序后判断是否合法。

### 提交#1 <-RE
主要问题在于：当相邻元素差值过大时，可能会超出数组 s 的边界（只定义了1001大小）。例如，如果输入序列中有两个相邻数字相差超过1000，就会发生越界访问。
更改：
```cpp
if (abs(v1[i] - v1[i - 1]) <= 1000)
	s[abs(v1[i] - v1[i - 1])] = 1;
```

### 提交#2 <-AC
#### 关键代码
```cpp
```cpp
int n;
int s[1001] = {0};

void solve() {
    cin >> n;
    vector<int> v1(n);
    for (int &n : v1) cin >> n;
    for (int i = 1; i < n; ++i) {
        if (abs(v1[i] - v1[i - 1]) <= 1000) 
            s[abs(v1[i] - v1[i - 1])] = 1;
    }
    bool flag = true;
    for (int i = 1; i <= n - 1; ++i) {
        if (s[i] != 1) {
            flag = false;
            break;
        }
    }
    cout << (flag  ? "Jolly" : "Not jolly") << '\n';
}

```

### 优化
实际上，如果任何相邻元素的差的绝对值大于 $n-1$ ，那么这个序列肯定不是欢乐跳序列，因为差值必须在 $(1, n-1)$ 之间。
```cpp
bool flag = true;
for (int i = 1; i < n; ++i) {
	int diff = abs(v1[i] - v1[i - 1]);
	// 如果差值超出范围1~(n-1)，直接判定为非欢乐跳
	if (diff < 1 || diff > n - 1) {
		flag = false;
		break;
	}
	s[diff] = 1;
}
```

```cpp
// 只有当所有差值都在范围内，才需要检查是否包含所有1到n-1的数
if (flag) {
	for (int i = 1; i <= n - 1; ++i) {
		if (s[i] != 1) {
			flag = false;
			break;
		}
	}
}
```

