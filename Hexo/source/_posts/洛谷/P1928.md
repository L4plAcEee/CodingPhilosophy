## Daily::算法 @[P1928 外星密码](https://www.luogu.com.cn/problem/P1928)
### 题目描述
有了防护伞，并不能完全避免 2012 的灾难。地球防卫小队决定去求助外星种族的帮助。经过很长时间的努力，小队终于收到了外星生命的回信。但是外星人发过来的却是一串密码。只有解开密码，才能知道外星人给的准确回复。解开密码的第一道工序就是解压缩密码，外星人对于连续的若干个相同的子串 X 会压缩为 $[DX]$ 的形式（D 是一个整数且 1≤D≤99），比如说字符串 CBCBCBCB 就压缩为 $[4CB]$ 或者$[2[2CB]]$，类似于后面这种压缩之后再压缩的称为二重压缩。如果是 $[2[2[2CB]]]$ 则是三重的。现在我们给你外星人发送的密码，请你对其进行解压缩。

### 思路#0 <递归> <-AC
先用递归模拟流程
1. 遇到数字 -> 积累轮数
2. 遇到字母 -> 构造串
3. 遇到`[]` -> 调用递归

#### Mistake
1. `repeat * weight` 计算顺序反了
```cpp
repeat = repeat * weight + (int)(s[i] - '0');
weight *= 10;
```
正确写法：
```cpp
repeat = repeat * 10 + (s[i] - '0');
```
2. `i++` 在 `solve(s, i);` 调用前增加了作用域外的变量
在处理 `[` 和 `]` 时使用了 `i++`，这会导致 `for` 循环外的 `i` 不被更新到递归中
**问题在于：** 递归后 `i` 其实应该由内部更新回来，不应该在调用前手动 `i++`。
**正确写法：** 直接进入递归，循环中不要再 `i++`，而应改为使用 `while` 循环或将 `i` 控制从 `idx` 接手。

正确写法：直接进入递归，循环中不要再 `i++`，而应改为使用 `while` 循环或将 `i` 控制从 `idx` 接手。
2. `return string(res, repeat);`
`string(res, repeat)` 实际是使用字符串构造的子串，而不是重复构造。
应该这样
```cpp
string tmp;
while (repeat--) tmp += res;
return tmp;
```

#### 关键代码
```cpp
string solve(string &s, int &idx) {
    string res;
    int repeat = 0;
    while (idx < s.length()) {
        char cur = s[idx++];
        if (isdigit(cur)) {
            repeat = repeat * 10 + (cur - '0');
        } else if (cur == '[') {
            res += solve(s, idx);
        } else if (isalpha(cur)) {
            res += cur;
        } else if (cur == ']') {
            string temp = res;
            while (repeat > 1) {
                res += temp;
                repeat--;
            }
            return res;
        }
    }
    return res;
}
```

#### 关键点
> 在递归的层层嵌套中 厘清 当前来到的位置。

这是处理递归解析类题目的核心思想，尤其是在需要携带上下文状态（如当前索引）的场景中，**明确当前递归所处的“位置”以及其作用域内该做什么，是解题的关键**。

**为什么这段代码有效？**
你的实现利用了一个巧妙的结构：
- 每次进入 `solve`，会构造当前层级的字符串 `res`；
- 当遇到 `]`，说明当前层级的括号结束，此时将整个 `res` 重复 `repeat` 次（原本是 1 次，`repeat-1` 次追加）；
- 然后 `return` 给上一层递归。
虽然重复操作在 `]` 处处理，并不是在 `[` 之后立刻处理，但由于你递归层级对应得非常清晰，**嵌套结构下不会错位**，因此也能得到正确的结果。

#### 可能的优化 <显式栈>
这题用递归做是因为题目保证最大解压深度（即递归深度）不超过十层，所以普通递归就不会爆栈帧空间。
这是一个“**软约束**”支撑下的简洁递归实现，但它的本质依然是**深度优先解析嵌套结构**。这在多数平台 AC 是没有问题的。
如果递归层数深了，可能就要用栈模拟递归行为（显式栈）了。
###### 显式栈思路：
我们可以维护两个栈：
1. **字符串栈** `resStack`：保存每一层返回前的 `res`；
2. **数字栈** `repeatStack`：保存每一层的 `repeat`；
##### 模拟过程：
- 遇到数字 → 构造 `repeat`;
- 遇到 `[` → 压栈当前 `res` 和 `repeat`，重置当前 `res`;
- 遇到 `]` → 弹出 `repeat` 和上层 `res`，拼接多次后合并；
- 遇到字母 → 当前 `res += ch`。

