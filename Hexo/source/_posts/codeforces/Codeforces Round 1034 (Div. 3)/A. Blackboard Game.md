---
笔记: 2025-07-02
摘要: Codeforces Round 1034 (Div. 3)
tags:
  - 题解
---
## 题目解析

这个题的本质是一个博弈论问题。初始时黑板上有 0,1,2,… n-1，两人轮流执行如下操作：

1. **Alice** 先选一个数字 a，从黑板上删除；
    
2. **Bob** 需要选一个还在黑板上的数 b，使得 $a + b \equiv 3 \pmod{4}$，然后也将其删除。
    

这个过程持续进行，直到某一方无法行动为止，该方失败。

---

## 模运算分析

我们考虑一个固定规则：

- Alice 选择一个数 a
    
- Bob 必须选择一个数 b，满足 $a + b \equiv 3 \pmod{4}$
    

换句话说，Bob 的选择必须满足：

$b \equiv 3 - a \pmod{4}$

因此，不同的 $a \pmod{4}$ 决定了 Bob 需要找的 b 是哪类数模 4：

| a mod 4 | 需要的 b mod 4 |
| ------- | ----------- |
| 0       | 3           |
| 1       | 2           |
| 2       | 1           |
| 3       | 0           |

这表明每次出牌都是一种“匹配模4”的过程。

---

## 结论
> 也就是说，因为以 4 为模数，所以 从 0 开始，计入0 每 4个数字是一个完整匹配周期，也就是说必然可以让 数字被抽完，而这意味着 Bob 的获胜（因为当数字被抽完时 Alice 将无数字可以抽。），也就是说 n  mod 4 == 0 即 Bob获胜的条件


**游戏一次消耗 2 个数，一次回合消耗一个「合法对」**。

而合法的对是什么？来自下面的模 4 对应表：

| Alice 选的数 $a \bmod 4$ | Bob 需要找的数 $b \bmod 4$ |
| --------------------- | --------------------- |
| 0                     | 3                     |
| 1                     | 2                     |
| 2                     | 1                     |
| 3                     | 0                     |

这些构成了 4 种合法模 4 配对组合。显然，这些配对正好涵盖了所有余数   $\bmod 4$。

---


从 0 到 n−1 的整数中，各个模 4 的余数个数是可预测的。

例如 n = 8 时，数列为：

```
0 1 2 3 4 5 6 7
模 4: 0 1 2 3 0 1 2 3
      → 每种模 4 各 2 个
```

我们可以配成以下合法对：

- (0,3), (1,2), (0,3), (1,2)
    

共 4 对，正好用完所有数（8 个数 → 4 轮）。

那此时最后一个操作完成时，轮到 Alice 行动，发现没有数了 → **Alice 输，Bob 赢。**

## 解
```cpp
int main() {
    int n, t;
    cin >> t;
    while (t--) {
        cin >> n;
        cout << ((n % 4) == 0 ? "Bob\n" : "Alice\n");
    }
}
```